<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>celery.concurrency.asynpool &mdash; Celery 3.1.23 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/celery.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.1.23',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
    <link rel="top" title="Celery 3.1.23 documentation" href="../../../index.html" />
    <link rel="up" title="celery.concurrency" href="../concurrency.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Celery 3.1.23 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../concurrency.html" accesskey="U">celery.concurrency</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
<div class="deck">

    
        <p>
        This document describes the current stable version of Celery (3.1). For development docs,
        <a href="http://docs.celeryproject.org/en/master/_modules/celery/concurrency/asynpool.html">go here</a>.
        </p>
    

</div>
    <h1>Source code for celery.concurrency.asynpool</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    celery.concurrency.asynpool</span>
<span class="sd">    ~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">    .. note::</span>

<span class="sd">        This module will be moved soon, so don&#39;t use it directly.</span>

<span class="sd">    Non-blocking version of :class:`multiprocessing.Pool`.</span>

<span class="sd">    This code deals with three major challenges:</span>

<span class="sd">        1) Starting up child processes and keeping them running.</span>
<span class="sd">        2) Sending jobs to the processes and receiving results back.</span>
<span class="sd">        3) Safely shutting down this system.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">select</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">pickle</span> <span class="kn">import</span> <span class="n">HIGHEST_PROTOCOL</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="n">WeakValueDictionary</span><span class="p">,</span> <span class="n">ref</span>

<span class="kn">from</span> <span class="nn">amqp.utils</span> <span class="kn">import</span> <span class="n">promise</span>
<span class="kn">from</span> <span class="nn">billiard.pool</span> <span class="kn">import</span> <span class="n">RUN</span><span class="p">,</span> <span class="n">TERMINATE</span><span class="p">,</span> <span class="n">ACK</span><span class="p">,</span> <span class="n">NACK</span><span class="p">,</span> <span class="n">WorkersJoined</span>
<span class="kn">from</span> <span class="nn">billiard</span> <span class="kn">import</span> <span class="n">pool</span> <span class="k">as</span> <span class="n">_pool</span>
<span class="kn">from</span> <span class="nn">billiard.compat</span> <span class="kn">import</span> <span class="n">buf_t</span><span class="p">,</span> <span class="n">setblocking</span><span class="p">,</span> <span class="n">isblocking</span>
<span class="kn">from</span> <span class="nn">billiard.einfo</span> <span class="kn">import</span> <span class="n">ExceptionInfo</span>
<span class="kn">from</span> <span class="nn">billiard.queues</span> <span class="kn">import</span> <span class="n">_SimpleQueue</span>
<span class="kn">from</span> <span class="nn">kombu.async</span> <span class="kn">import</span> <span class="n">READ</span><span class="p">,</span> <span class="n">WRITE</span><span class="p">,</span> <span class="n">ERR</span>
<span class="kn">from</span> <span class="nn">kombu.serialization</span> <span class="kn">import</span> <span class="n">pickle</span> <span class="k">as</span> <span class="n">_pickle</span>
<span class="kn">from</span> <span class="nn">kombu.utils</span> <span class="kn">import</span> <span class="n">fxrange</span>
<span class="kn">from</span> <span class="nn">kombu.utils.compat</span> <span class="kn">import</span> <span class="n">get_errno</span>
<span class="kn">from</span> <span class="nn">kombu.utils.eventio</span> <span class="kn">import</span> <span class="n">SELECT_BAD_FD</span>
<span class="kn">from</span> <span class="nn">celery.five</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">string_t</span><span class="p">,</span> <span class="n">text_t</span><span class="p">,</span> <span class="n">values</span>
<span class="kn">from</span> <span class="nn">celery.utils.log</span> <span class="kn">import</span> <span class="n">get_logger</span>
<span class="kn">from</span> <span class="nn">celery.utils.text</span> <span class="kn">import</span> <span class="n">truncate</span>
<span class="kn">from</span> <span class="nn">celery.worker</span> <span class="kn">import</span> <span class="n">state</span> <span class="k">as</span> <span class="n">worker_state</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_billiard</span> <span class="kn">import</span> <span class="n">read</span> <span class="k">as</span> <span class="n">__read__</span>
    <span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">unpack_from</span> <span class="k">as</span> <span class="n">_unpack_from</span>
    <span class="n">memoryview</span> <span class="o">=</span> <span class="n">memoryview</span>
    <span class="n">readcanbuf</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">unpack_from</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">_unpack_from</span><span class="o">=</span><span class="n">_unpack_from</span><span class="p">):</span>  <span class="c1"># noqa</span>
            <span class="k">return</span> <span class="n">_unpack_from</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">view</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>  <span class="c1"># &lt;- memoryview</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># unpack_from supports memoryview in 2.7.6 and 3.3+</span>
        <span class="n">unpack_from</span> <span class="o">=</span> <span class="n">_unpack_from</span>  <span class="c1"># noqa</span>

<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">def</span> <span class="nf">__read__</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">):</span>  <span class="c1"># noqa</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="n">readcanbuf</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># noqa</span>

    <span class="k">def</span> <span class="nf">unpack_from</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">iobuf</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">):</span>  <span class="c1"># noqa</span>
        <span class="k">return</span> <span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">iobuf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>  <span class="c1"># &lt;-- BytesIO</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">error</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span>

<span class="n">UNAVAIL</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">,</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">])</span>

<span class="c1">#: Constant sent by child process when started (ready to accept work)</span>
<span class="n">WORKER_UP</span> <span class="o">=</span> <span class="mi">15</span>

<span class="c1">#: A process must have started before this timeout (in secs.) expires.</span>
<span class="n">PROC_ALIVE_TIMEOUT</span> <span class="o">=</span> <span class="mf">4.0</span>

<span class="n">SCHED_STRATEGY_PREFETCH</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SCHED_STRATEGY_FAIR</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">SCHED_STRATEGIES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="bp">None</span><span class="p">:</span> <span class="n">SCHED_STRATEGY_PREFETCH</span><span class="p">,</span>
    <span class="s1">&#39;fair&#39;</span><span class="p">:</span> <span class="n">SCHED_STRATEGY_FAIR</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">RESULT_MAXLEN</span> <span class="o">=</span> <span class="mi">128</span>

<span class="n">Ack</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Ack&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;fd&#39;</span><span class="p">,</span> <span class="s1">&#39;payload&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">gen_not_started</span><span class="p">(</span><span class="n">gen</span><span class="p">):</span>
    <span class="c1"># gi_frame is None when generator stopped.</span>
    <span class="k">return</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span> <span class="ow">and</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">_get_job_writer</span><span class="p">(</span><span class="n">job</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_writer</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">writer</span><span class="p">()</span>  <span class="c1"># is a weakref</span>


<span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="n">readers</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">writers</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple wrapper to :class:`~select.select`.</span>

<span class="sd">    :param readers: Set of reader fds to test if readable.</span>
<span class="sd">    :param writers: Set of writer fds to test if writable.</span>
<span class="sd">    :param err: Set of fds to test for error condition.</span>

<span class="sd">    All fd sets passed must be mutable as this function</span>
<span class="sd">    will remove non-working fds from them, this also means</span>
<span class="sd">    the caller must make sure there are still fds in the sets</span>
<span class="sd">    before calling us again.</span>

<span class="sd">    :returns: tuple of ``(readable, writable, again)``, where</span>
<span class="sd">        ``readable`` is a set of fds that have data available for read,</span>
<span class="sd">        ``writable`` is a set of fds that is ready to be written to</span>
<span class="sd">        and ``again`` is a flag that if set means the caller must</span>
<span class="sd">        throw away the result and call us again.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">readers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">readers</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">readers</span>
    <span class="n">writers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">writers</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">writers</span>
    <span class="n">err</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">err</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">readers</span><span class="p">,</span> <span class="n">writers</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">SELECT_BAD_FD</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">readers</span> <span class="o">|</span> <span class="n">writers</span> <span class="o">|</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">fd</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">select</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SELECT_BAD_FD</span><span class="p">:</span>
                        <span class="k">raise</span>
                    <span class="n">readers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">err</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>


<span class="k">def</span> <span class="nf">_repr_result</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">orig_exc</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text_t</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">string_t</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Unrepresentable: {0!r} (o.__repr__ returns unicode?)&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">orig_exc</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="n">_pool</span><span class="o">.</span><span class="n">Worker</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pool worker process.&quot;&quot;&quot;</span>
    <span class="n">dead</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">on_loop_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="c1"># our version sends a WORKER_UP message when the process is ready</span>
        <span class="c1"># to accept work, this will tell the parent that the inqueue fd</span>
        <span class="c1"># is writable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">WORKER_UP</span><span class="p">,</span> <span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">)))</span>

    <span class="k">def</span> <span class="nf">prepare_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="n">RESULT_MAXLEN</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="n">truncate</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">ExceptionInfo</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">truncate</span><span class="p">(</span><span class="n">_repr_result</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="n">maxlen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">ResultHandler</span><span class="p">(</span><span class="n">_pool</span><span class="o">.</span><span class="n">ResultHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handles messages from the pool processes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fileno_to_outq&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_process_alive</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;on_process_alive&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResultHandler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># add our custom message handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_handlers</span><span class="p">[</span><span class="n">WORKER_UP</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_process_alive</span>

    <span class="k">def</span> <span class="nf">_recv_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_reader</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
                      <span class="n">__read__</span><span class="o">=</span><span class="n">__read__</span><span class="p">,</span> <span class="n">readcanbuf</span><span class="o">=</span><span class="n">readcanbuf</span><span class="p">,</span>
                      <span class="n">BytesIO</span><span class="o">=</span><span class="n">BytesIO</span><span class="p">,</span> <span class="n">unpack_from</span><span class="o">=</span><span class="n">unpack_from</span><span class="p">,</span>
                      <span class="n">load</span><span class="o">=</span><span class="n">_pickle</span><span class="o">.</span><span class="n">load</span><span class="p">):</span>
        <span class="n">Hr</span> <span class="o">=</span> <span class="n">Br</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">readcanbuf</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">bufv</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">bufv</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
        <span class="c1"># header</span>

        <span class="k">while</span> <span class="n">Hr</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">__read__</span><span class="p">(</span>
                    <span class="n">fd</span><span class="p">,</span> <span class="n">bufv</span><span class="p">[</span><span class="n">Hr</span><span class="p">:]</span> <span class="k">if</span> <span class="n">readcanbuf</span> <span class="k">else</span> <span class="n">bufv</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">Hr</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">yield</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;End of file during message&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">Hr</span>
                           <span class="k">else</span> <span class="ne">EOFError</span><span class="p">())</span>
                <span class="n">Hr</span> <span class="o">+=</span> <span class="n">n</span>

        <span class="n">body_size</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack_from</span><span class="p">(</span><span class="s1">&#39;&gt;i&#39;</span><span class="p">,</span> <span class="n">bufv</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">readcanbuf</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">body_size</span><span class="p">)</span>
            <span class="n">bufv</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">bufv</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>

        <span class="k">while</span> <span class="n">Br</span> <span class="o">&lt;</span> <span class="n">body_size</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">__read__</span><span class="p">(</span>
                    <span class="n">fd</span><span class="p">,</span> <span class="n">bufv</span><span class="p">[</span><span class="n">Br</span><span class="p">:]</span> <span class="k">if</span> <span class="n">readcanbuf</span> <span class="k">else</span> <span class="n">bufv</span><span class="p">,</span> <span class="n">body_size</span> <span class="o">-</span> <span class="n">Br</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">yield</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;End of file during message&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">Br</span>
                           <span class="k">else</span> <span class="ne">EOFError</span><span class="p">())</span>
                <span class="n">Br</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="n">add_reader</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_event</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">readcanbuf</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">bufv</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bufv</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">bufv</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_process_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coroutine that reads messages from the pool processes</span>
<span class="sd">        and calls the appropriate handler.&quot;&quot;&quot;</span>
        <span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileno_to_outq</span>
        <span class="n">on_state_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_state_change</span>
        <span class="n">add_reader</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span>
        <span class="n">remove_reader</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove_reader</span>
        <span class="n">recv_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_message</span>

        <span class="k">def</span> <span class="nf">on_result_readable</span><span class="p">(</span><span class="n">fileno</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fileno_to_outq</span><span class="p">[</span><span class="n">fileno</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># process gone</span>
                <span class="k">return</span> <span class="n">remove_reader</span><span class="p">(</span><span class="n">fileno</span><span class="p">)</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">recv_message</span><span class="p">(</span><span class="n">add_reader</span><span class="p">,</span> <span class="n">fileno</span><span class="p">,</span> <span class="n">on_state_change</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>
                <span class="n">remove_reader</span><span class="p">(</span><span class="n">fileno</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">add_reader</span><span class="p">(</span><span class="n">fileno</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">on_result_readable</span>

    <span class="k">def</span> <span class="nf">register_with_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_process_result</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileno</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not registered with event loop&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_stop_not_started</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is always used to stop when the helper thread is not</span>
<span class="sd">        started.&quot;&quot;&quot;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">check_timeouts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_timeouts</span>
        <span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileno_to_outq</span>
        <span class="n">on_state_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_state_change</span>
        <span class="n">join_exited_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_exited_workers</span>

        <span class="c1"># flush the processes outqueues until they have all terminated.</span>
        <span class="n">outqueues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fileno_to_outq</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">cache</span> <span class="ow">and</span> <span class="n">outqueues</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">TERMINATE</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check_timeouts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># make sure tasks with a time limit will time out.</span>
                <span class="n">check_timeouts</span><span class="p">()</span>
            <span class="c1"># cannot iterate and remove at the same time</span>
            <span class="n">pending_remove_fd</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">outqueues</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flush_outqueue</span><span class="p">(</span>
                    <span class="n">fd</span><span class="p">,</span> <span class="n">pending_remove_fd</span><span class="o">.</span><span class="n">discard</span><span class="p">,</span> <span class="n">fileno_to_outq</span><span class="p">,</span>
                    <span class="n">on_state_change</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">join_exited_workers</span><span class="p">(</span><span class="n">shutdown</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">WorkersJoined</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;result handler: all workers terminated&#39;</span><span class="p">)</span>
            <span class="n">outqueues</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">pending_remove_fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flush_outqueue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">remove</span><span class="p">,</span> <span class="n">process_index</span><span class="p">,</span> <span class="n">on_state_change</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># process already found terminated</span>
            <span class="c1"># which means its outqueue has already been processed</span>
            <span class="c1"># by the worker lost handler.</span>
            <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

        <span class="n">reader</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">setblocking</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
                <span class="n">on_state_change</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">setblocking</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AsynPool</span><span class="p">(</span><span class="n">_pool</span><span class="o">.</span><span class="n">Pool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pool version that uses AIO instead of helper threads.&quot;&quot;&quot;</span>
    <span class="n">ResultHandler</span> <span class="o">=</span> <span class="n">ResultHandler</span>
    <span class="n">Worker</span> <span class="o">=</span> <span class="n">Worker</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">synack</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">sched_strategy</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sched_strategy</span> <span class="o">=</span> <span class="n">SCHED_STRATEGIES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sched_strategy</span><span class="p">,</span>
                                                   <span class="n">sched_strategy</span><span class="p">)</span>
        <span class="n">processes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="k">if</span> <span class="n">processes</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synack</span> <span class="o">=</span> <span class="n">synack</span>
        <span class="c1"># create queue-pairs for all our processes in advance.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">create_process_queues</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">processes</span><span class="p">))</span>

        <span class="c1"># inqueue fileno -&gt; process mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># outqueue fileno -&gt; process mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># synqueue fileno -&gt; process mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># We keep track of processes that have not yet</span>
        <span class="c1"># sent a WORKER_UP message.  If a process fails to send</span>
        <span class="c1"># this message within proc_up_timeout we terminate it</span>
        <span class="c1"># and hope the next process will recover.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proc_alive_timeout</span> <span class="o">=</span> <span class="n">PROC_ALIVE_TIMEOUT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># denormalized set of all inqueues.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Set of fds being written to (busy)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Set of active co-routines currently writing jobs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Set of fds that are busy (executing task)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_worker_as_available</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span><span class="o">.</span><span class="n">discard</span>

        <span class="c1"># Holds jobs waiting to be written to child processes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">AsynPool</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">processes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">:</span>
            <span class="c1"># create initial mappings, these will be updated</span>
            <span class="c1"># as processes are recycled, or found lost elsewhere.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_soft_timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_hard_timeout</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout_handler</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_soft_timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout_handler</span><span class="o">.</span><span class="n">on_soft_timeout</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_hard_timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout_handler</span><span class="o">.</span><span class="n">on_hard_timeout</span>

    <span class="k">def</span> <span class="nf">_create_worker_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>  <span class="c1"># Issue #2927</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AsynPool</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_create_worker_process</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_event_process_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="c1"># This method is called whenever the process sentinel is readable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_untrack_child_process</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_track_child_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fd</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># we need to duplicate the fd here to carefully</span>
            <span class="c1"># control when the fd is removed from the process table,</span>
            <span class="c1"># as once the original fd is closed we cannot unregister</span>
            <span class="c1"># the fd from epoll(7) anymore, causing a 100% CPU poll loop.</span>
            <span class="n">fd</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">dup</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">_popen</span><span class="o">.</span><span class="n">sentinel</span><span class="p">)</span>
        <span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_process_exit</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_untrack_child_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fd</span><span class="p">,</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">_sentinel_poll</span><span class="p">,</span> <span class="bp">None</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_with_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Registers the async pool with the current event loop.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result_handler</span><span class="o">.</span><span class="n">register_with_event_loop</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_result_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_handler</span><span class="o">.</span><span class="n">handle_event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_timelimit_handlers</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_process_handlers</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_write_handlers</span><span class="p">(</span><span class="n">hub</span><span class="p">)</span>

        <span class="c1"># Add handler for when a process exits (calls maintain_pool)</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_track_child_process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">]</span>
        <span class="c1"># Handle_result_event is called whenever one of the</span>
        <span class="c1"># result queues are readable.</span>
        <span class="p">[</span><span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_result_event</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span><span class="p">]</span>

        <span class="c1"># Timers include calling maintain_pool at a regular interval</span>
        <span class="c1"># to be certain processes are restarted.</span>
        <span class="k">for</span> <span class="n">handler</span><span class="p">,</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">items</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timers</span><span class="p">):</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">call_repeatedly</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>

        <span class="n">hub</span><span class="o">.</span><span class="n">on_tick</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_poll_start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_timelimit_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span> <span class="n">now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For async pool this sets up the handlers used</span>
<span class="sd">        to implement time limits.&quot;&quot;&quot;</span>
        <span class="n">call_later</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">call_later</span>
        <span class="n">trefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tref_for_id</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">on_timeout_set</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">soft</span><span class="p">:</span>
                <span class="n">trefs</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_later</span><span class="p">(</span>
                    <span class="n">soft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_soft_timeout</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">hard</span><span class="p">:</span>
                <span class="n">trefs</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_later</span><span class="p">(</span>
                    <span class="n">hard</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_hard_timeout</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_timeout_set</span> <span class="o">=</span> <span class="n">on_timeout_set</span>

        <span class="k">def</span> <span class="nf">_discard_tref</span><span class="p">(</span><span class="n">job</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tref</span> <span class="o">=</span> <span class="n">trefs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                <span class="n">tref</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="k">del</span><span class="p">(</span><span class="n">tref</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>  <span class="c1"># out of scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_discard_tref</span> <span class="o">=</span> <span class="n">_discard_tref</span>

        <span class="k">def</span> <span class="nf">on_timeout_cancel</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="n">_discard_tref</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_job</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_timeout_cancel</span> <span class="o">=</span> <span class="n">on_timeout_cancel</span>

    <span class="k">def</span> <span class="nf">_on_soft_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span> <span class="n">now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
        <span class="c1"># only used by async pool.</span>
        <span class="k">if</span> <span class="n">hard</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tref_for_id</span><span class="p">[</span><span class="n">job</span><span class="p">]</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">call_at</span><span class="p">(</span>
                <span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">hard</span> <span class="o">-</span> <span class="n">soft</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_hard_timeout</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">job</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># job ready</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_soft_timeout</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hard</span><span class="p">:</span>
                <span class="c1"># remove tref</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_discard_tref</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_on_hard_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">):</span>
        <span class="c1"># only used by async pool.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">job</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># job ready</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_hard_timeout</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># remove tref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_discard_tref</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_job_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">inqW_fd</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_worker_as_available</span><span class="p">(</span><span class="n">inqW_fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_process_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span> <span class="n">READ</span><span class="o">=</span><span class="n">READ</span><span class="p">,</span> <span class="n">ERR</span><span class="o">=</span><span class="n">ERR</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For async pool this will create the handlers called</span>
<span class="sd">        when a process is up/down and etc.&quot;&quot;&quot;</span>
        <span class="n">add_reader</span><span class="p">,</span> <span class="n">remove_reader</span><span class="p">,</span> <span class="n">remove_writer</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">add_reader</span><span class="p">,</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">,</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove_writer</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
        <span class="n">all_inqueues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span>
        <span class="n">fileno_to_inq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span>
        <span class="n">fileno_to_outq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span>
        <span class="n">fileno_to_synq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span>
        <span class="n">busy_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span>
        <span class="n">handle_result_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_result_event</span>
        <span class="n">process_flush_queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_flush_queues</span>
        <span class="n">waiting_to_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span>

        <span class="k">def</span> <span class="nf">verify_process_alive</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">()</span>  <span class="c1"># is a weakref</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">proc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">()</span> <span class="ow">and</span>
                    <span class="n">proc</span> <span class="ow">in</span> <span class="n">waiting_to_start</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span> <span class="ow">in</span> <span class="n">fileno_to_outq</span>
                <span class="k">assert</span> <span class="n">fileno_to_outq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">]</span> <span class="ow">is</span> <span class="n">proc</span>
                <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span> <span class="ow">in</span> <span class="n">hub</span><span class="o">.</span><span class="n">readers</span>
                <span class="n">error</span><span class="p">(</span><span class="s1">&#39;Timed out waiting for UP message from </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_process_up</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Called when a process has started.&quot;&quot;&quot;</span>
            <span class="c1"># If we got the same fd as a previous process then we will also</span>
            <span class="c1"># receive jobs in the old buffer, so we need to reset the</span>
            <span class="c1"># job._write_to and job._scheduled_for attributes used to recover</span>
            <span class="c1"># message boundaries when processes exit.</span>
            <span class="n">infd</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span>
            <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">values</span><span class="p">(</span><span class="n">cache</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="ow">and</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="o">==</span> <span class="n">infd</span><span class="p">:</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="o">=</span> <span class="n">proc</span>
                <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="ow">and</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="o">==</span> <span class="n">infd</span><span class="p">:</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="o">=</span> <span class="n">proc</span>
            <span class="n">fileno_to_outq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>

            <span class="c1"># maintain_pool is called whenever a process exits.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_track_child_process</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span>

            <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>

            <span class="c1"># handle_result_event is called when the processes outqueue is</span>
            <span class="c1"># readable.</span>
            <span class="n">add_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">,</span> <span class="n">handle_result_event</span><span class="p">,</span> <span class="n">proc</span><span class="o">.</span><span class="n">outqR_fd</span><span class="p">)</span>

            <span class="n">waiting_to_start</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proc_alive_timeout</span><span class="p">,</span> <span class="n">verify_process_alive</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">proc</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_process_up</span> <span class="o">=</span> <span class="n">on_process_up</span>

        <span class="k">def</span> <span class="nf">_remove_from_index</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">remove_fun</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="c1"># this remove the file descriptors for a process from</span>
            <span class="c1"># the indices.  we have to make sure we don&#39;t overwrite</span>
            <span class="c1"># another processes fds, as the fds may be reused.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fd</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
                <span class="k">return</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="ow">is</span> <span class="n">proc</span><span class="p">:</span>
                    <span class="c1"># fd has not been reused so we can remove it from index.</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remove_fun</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fd</span>

        <span class="k">def</span> <span class="nf">on_process_down</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Called when a worker process exits.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="s1">&#39;dead&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="n">process_flush_queues</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
            <span class="n">_remove_from_index</span><span class="p">(</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">fileno_to_outq</span><span class="p">,</span> <span class="n">remove_reader</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="p">:</span>
                <span class="n">_remove_from_index</span><span class="p">(</span>
                    <span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="o">.</span><span class="n">_writer</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">fileno_to_synq</span><span class="p">,</span> <span class="n">remove_writer</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">inq</span> <span class="o">=</span> <span class="n">_remove_from_index</span><span class="p">(</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">fileno_to_inq</span><span class="p">,</span> <span class="n">remove_writer</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">all_inqueues</span><span class="o">.</span><span class="n">discard</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">inq</span><span class="p">:</span>
                <span class="n">busy_workers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">inq</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_untrack_child_process</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">hub</span><span class="p">)</span>
            <span class="n">waiting_to_start</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span><span class="p">)</span>
            <span class="n">remove_writer</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
            <span class="n">remove_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">synqR_fd</span><span class="p">:</span>
                <span class="n">remove_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">)</span>
                <span class="n">remove_reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">synq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_process_down</span> <span class="o">=</span> <span class="n">on_process_down</span>

    <span class="k">def</span> <span class="nf">_create_write_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hub</span><span class="p">,</span>
                               <span class="n">pack</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">,</span> <span class="n">dumps</span><span class="o">=</span><span class="n">_pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span>
                               <span class="n">protocol</span><span class="o">=</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For async pool this creates the handlers used to write data to</span>
<span class="sd">        child processes.&quot;&quot;&quot;</span>
        <span class="n">fileno_to_inq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span>
        <span class="n">fileno_to_synq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span>
        <span class="n">outbound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span>
        <span class="n">pop_message</span> <span class="o">=</span> <span class="n">outbound</span><span class="o">.</span><span class="n">popleft</span>
        <span class="n">append_message</span> <span class="o">=</span> <span class="n">outbound</span><span class="o">.</span><span class="n">append</span>
        <span class="n">put_back_message</span> <span class="o">=</span> <span class="n">outbound</span><span class="o">.</span><span class="n">appendleft</span>
        <span class="n">all_inqueues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span>
        <span class="n">active_writes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span>
        <span class="n">active_writers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span>
        <span class="n">busy_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">all_inqueues</span><span class="o">.</span><span class="n">difference</span>
        <span class="n">add_writer</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">add_writer</span>
        <span class="n">hub_add</span><span class="p">,</span> <span class="n">hub_remove</span> <span class="o">=</span> <span class="n">hub</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">hub</span><span class="o">.</span><span class="n">remove</span>
        <span class="n">mark_write_fd_as_active</span> <span class="o">=</span> <span class="n">active_writes</span><span class="o">.</span><span class="n">add</span>
        <span class="n">mark_write_gen_as_active</span> <span class="o">=</span> <span class="n">active_writers</span><span class="o">.</span><span class="n">add</span>
        <span class="n">mark_worker_as_busy</span> <span class="o">=</span> <span class="n">busy_workers</span><span class="o">.</span><span class="n">add</span>
        <span class="n">write_generator_done</span> <span class="o">=</span> <span class="n">active_writers</span><span class="o">.</span><span class="n">discard</span>
        <span class="n">get_job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">__getitem__</span>
        <span class="n">write_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span>
        <span class="n">is_fair_strategy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sched_strategy</span> <span class="o">==</span> <span class="n">SCHED_STRATEGY_FAIR</span>
        <span class="n">revoked_tasks</span> <span class="o">=</span> <span class="n">worker_state</span><span class="o">.</span><span class="n">revoked</span>
        <span class="n">getpid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span>

        <span class="n">precalc</span> <span class="o">=</span> <span class="p">{</span><span class="n">ACK</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_payload</span><span class="p">(</span><span class="n">ACK</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">)),</span>
                   <span class="n">NACK</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_payload</span><span class="p">(</span><span class="n">NACK</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">))}</span>

        <span class="k">def</span> <span class="nf">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">_time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
            <span class="c1"># puts back at the end of the queue</span>
            <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_terminated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> \
                    <span class="n">job</span><span class="o">.</span><span class="n">correlation_id</span> <span class="ow">in</span> <span class="n">revoked_tasks</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">_ack</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">_time</span><span class="p">(),</span> <span class="n">getpid</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">job</span><span class="o">.</span><span class="n">_set_terminated</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">_terminated</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># XXX linear lookup, should find a better way,</span>
                <span class="c1"># but this happens rarely and is here to protect against races.</span>
                <span class="k">if</span> <span class="n">job</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outbound</span><span class="p">:</span>
                    <span class="n">outbound</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span> <span class="o">=</span> <span class="n">_put_back</span>

        <span class="c1"># called for every event loop iteration, and if there</span>
        <span class="c1"># are messages pending this will schedule writing one message</span>
        <span class="c1"># by registering the &#39;schedule_writes&#39; function for all currently</span>
        <span class="c1"># inactive inqueues (not already being written to)</span>

        <span class="c1"># consolidate means the event loop will merge them</span>
        <span class="c1"># and call the callback once with the list writable fds as</span>
        <span class="c1"># argument.  Using this means we minimize the risk of having</span>
        <span class="c1"># the same fd receive every task if the pipe read buffer is not</span>
        <span class="c1"># full.</span>
        <span class="k">if</span> <span class="n">is_fair_strategy</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">on_poll_start</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">outbound</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">busy_workers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_inqueues</span><span class="p">):</span>
                    <span class="n">inactive</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)</span>
                    <span class="p">[</span><span class="n">hub_add</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="n">ERR</span><span class="p">,</span> <span class="n">consolidate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">inactive</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">on_poll_start</span><span class="p">():</span>  <span class="c1"># noqa</span>
                <span class="k">if</span> <span class="n">outbound</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">hub_add</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">WRITE</span> <span class="o">|</span> <span class="n">ERR</span><span class="p">,</span> <span class="n">consolidate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_poll_start</span> <span class="o">=</span> <span class="n">on_poll_start</span>

        <span class="k">def</span> <span class="nf">on_inqueue_close</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
            <span class="c1"># Makes sure the fd is removed from tracking when</span>
            <span class="c1"># the connection is closed, this is essential as fds may be reused.</span>
            <span class="n">busy_workers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fileno_to_inq</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="ow">is</span> <span class="n">proc</span><span class="p">:</span>
                    <span class="n">fileno_to_inq</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">all_inqueues</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                    <span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_inqueue_close</span> <span class="o">=</span> <span class="n">on_inqueue_close</span>

        <span class="k">def</span> <span class="nf">schedule_writes</span><span class="p">(</span><span class="n">ready_fds</span><span class="p">,</span> <span class="n">curindex</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Schedule write operation to ready file descriptor.</span>
            <span class="c1"># The file descriptor is writeable, but that does not</span>
            <span class="c1"># mean the process is currently reading from the socket.</span>
            <span class="c1"># The socket is buffered so writeable simply means that</span>
            <span class="c1"># the buffer can accept at least 1 byte of data.</span>

            <span class="c1"># This means we have to cycle between the ready fds.</span>
            <span class="c1"># the first version used shuffle, but using i % total</span>
            <span class="c1"># is about 30% faster with many processes.  The latter</span>
            <span class="c1"># also shows more fairness in write stats when used with</span>
            <span class="c1"># many processes [XXX On OS X, this may vary depending</span>
            <span class="c1"># on event loop implementation (i.e select vs epoll), so</span>
            <span class="c1"># have to test further]</span>
            <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ready_fds</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">):</span>
                <span class="n">ready_fd</span> <span class="o">=</span> <span class="n">ready_fds</span><span class="p">[</span><span class="n">curindex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">total</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ready_fd</span> <span class="ow">in</span> <span class="n">active_writes</span><span class="p">:</span>
                    <span class="c1"># already writing to this fd</span>
                    <span class="n">curindex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">is_fair_strategy</span> <span class="ow">and</span> <span class="n">ready_fd</span> <span class="ow">in</span> <span class="n">busy_workers</span><span class="p">:</span>
                    <span class="c1"># worker is already busy with another task</span>
                    <span class="n">curindex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">ready_fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_inqueues</span><span class="p">:</span>
                    <span class="n">hub_remove</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">)</span>
                    <span class="n">curindex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">job</span> <span class="o">=</span> <span class="n">pop_message</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># no more messages, remove all inactive fds from the hub.</span>
                    <span class="c1"># this is important since the fds are always writeable</span>
                    <span class="c1"># as long as there&#39;s 1 byte left in the buffer, and so</span>
                    <span class="c1"># this may create a spinloop where the event loop</span>
                    <span class="c1"># always wakes up.</span>
                    <span class="k">for</span> <span class="n">inqfd</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">(</span><span class="n">active_writes</span><span class="p">):</span>
                        <span class="n">hub_remove</span><span class="p">(</span><span class="n">inqfd</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>  <span class="c1"># job not accepted by another worker</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># keep track of what process the write operation</span>
                            <span class="c1"># was scheduled for.</span>
                            <span class="n">proc</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="o">=</span> <span class="n">fileno_to_inq</span><span class="p">[</span><span class="n">ready_fd</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="c1"># write was scheduled for this fd but the process</span>
                            <span class="c1"># has since exited and the message must be sent to</span>
                            <span class="c1"># another process.</span>
                            <span class="n">put_back_message</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                            <span class="n">curindex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>
                        <span class="n">cor</span> <span class="o">=</span> <span class="n">_write_job</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">ready_fd</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
                        <span class="n">job</span><span class="o">.</span><span class="n">_writer</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
                        <span class="n">mark_write_gen_as_active</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
                        <span class="n">mark_write_fd_as_active</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">)</span>
                        <span class="n">mark_worker_as_busy</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">)</span>

                        <span class="c1"># Try to write immediately, in case there&#39;s an error.</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="nb">next</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EBADF</span><span class="p">:</span>
                                <span class="k">raise</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">add_writer</span><span class="p">(</span><span class="n">ready_fd</span><span class="p">,</span> <span class="n">cor</span><span class="p">)</span>
                <span class="n">curindex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">hub</span><span class="o">.</span><span class="n">consolidate_callback</span> <span class="o">=</span> <span class="n">schedule_writes</span>

        <span class="k">def</span> <span class="nf">send_job</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
            <span class="c1"># Schedule writing job request for when one of the process</span>
            <span class="c1"># inqueues are writable.</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span>
            <span class="n">body_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&gt;I&#39;</span><span class="p">,</span> <span class="n">body_size</span><span class="p">)</span>
            <span class="c1"># index 1,0 is the job ID.</span>
            <span class="n">job</span> <span class="o">=</span> <span class="n">get_job</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">job</span><span class="o">.</span><span class="n">_payload</span> <span class="o">=</span> <span class="n">buf_t</span><span class="p">(</span><span class="n">header</span><span class="p">),</span> <span class="n">buf_t</span><span class="p">(</span><span class="n">body</span><span class="p">),</span> <span class="n">body_size</span>
            <span class="n">append_message</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quick_put</span> <span class="o">=</span> <span class="n">send_job</span>

        <span class="k">def</span> <span class="nf">on_not_recovering</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;Process inqueue damaged: </span><span class="si">%r</span><span class="s1"> </span><span class="si">%r</span><span class="s1">: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="n">proc</span><span class="p">,</span> <span class="n">proc</span><span class="o">.</span><span class="n">exitcode</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
                <span class="n">proc</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="n">hub</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_write_job</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">):</span>
            <span class="c1"># writes job to the worker process.</span>
            <span class="c1"># Operation must complete if more than one byte of data</span>
            <span class="c1"># was written.  If the broker connection is lost</span>
            <span class="c1"># and no data was written the operation shall be canceled.</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">body_size</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_payload</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># job result keeps track of what process the job is sent to.</span>
                <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="o">=</span> <span class="n">proc</span>
                <span class="n">send</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">send_job_offset</span>

                <span class="n">Hw</span> <span class="o">=</span> <span class="n">Bw</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># write header</span>
                <span class="k">while</span> <span class="n">Hw</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Hw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">Hw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="c1"># suspend until more data</span>
                        <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                            <span class="n">on_not_recovering</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
                        <span class="k">yield</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># write body</span>
                <span class="k">while</span> <span class="n">Bw</span> <span class="o">&lt;</span> <span class="n">body_size</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Bw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">Bw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="c1"># suspend until more data</span>
                        <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                            <span class="n">on_not_recovering</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
                        <span class="k">yield</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">hub_remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="n">write_stats</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># message written, so this fd is now available</span>
                <span class="n">active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="n">write_generator_done</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">_writer</span><span class="p">())</span>  <span class="c1"># is a weakref</span>

        <span class="k">def</span> <span class="nf">send_ack</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">WRITE</span><span class="o">=</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">ERR</span><span class="o">=</span><span class="n">ERR</span><span class="p">):</span>
            <span class="c1"># Only used when synack is enabled.</span>
            <span class="c1"># Schedule writing ack response for when the fd is writeable.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">Ack</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">precalc</span><span class="p">[</span><span class="n">response</span><span class="p">])</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">promise</span><span class="p">(</span><span class="n">write_generator_done</span><span class="p">)</span>
            <span class="n">cor</span> <span class="o">=</span> <span class="n">_write_ack</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
            <span class="n">mark_write_gen_as_active</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
            <span class="n">mark_write_fd_as_active</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">callback</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">cor</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">add_writer</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_ack</span> <span class="o">=</span> <span class="n">send_ack</span>

        <span class="k">def</span> <span class="nf">_write_ack</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="c1"># writes ack back to the worker if synack enabled.</span>
            <span class="c1"># this operation *MUST* complete, otherwise</span>
            <span class="c1"># the worker process will hang waiting for the ack.</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">body_size</span> <span class="o">=</span> <span class="n">ack</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">proc</span> <span class="o">=</span> <span class="n">fileno_to_synq</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># process died, we can safely discard the ack at this</span>
                    <span class="c1"># point.</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
                <span class="n">send</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">send_syn_offset</span>

                <span class="n">Hw</span> <span class="o">=</span> <span class="n">Bw</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># write header</span>
                <span class="k">while</span> <span class="n">Hw</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Hw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">Hw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="k">yield</span>

                <span class="c1"># write body</span>
                <span class="k">while</span> <span class="n">Bw</span> <span class="o">&lt;</span> <span class="n">body_size</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">Bw</span> <span class="o">+=</span> <span class="n">send</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">Bw</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                            <span class="k">raise</span>
                        <span class="c1"># suspend until more data</span>
                        <span class="k">yield</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
                    <span class="n">callback</span><span class="p">()</span>
                <span class="c1"># message written, so this fd is now available</span>
                <span class="n">active_writes</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="n">TERMINATE</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># cancel all tasks that have not been accepted so that NACK is sent.</span>
        <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>
                <span class="n">job</span><span class="o">.</span><span class="n">_cancel</span><span class="p">()</span>

        <span class="c1"># clear the outgoing buffer as the tasks will be redelivered by</span>
        <span class="c1"># the broker anyway.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># ...but we must continue writing the payloads we already started</span>
            <span class="c1"># to keep message boundaries.</span>
            <span class="c1"># The messages may be NACK&#39;ed later if synack is enabled.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="n">RUN</span><span class="p">:</span>
                <span class="c1"># flush outgoing buffers</span>
                <span class="n">intervals</span> <span class="o">=</span> <span class="n">fxrange</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">repeatlast</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">owned_by</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">):</span>
                    <span class="n">writer</span> <span class="o">=</span> <span class="n">_get_job_writer</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">owned_by</span><span class="p">[</span><span class="n">writer</span><span class="p">]</span> <span class="o">=</span> <span class="n">job</span>

                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="p">:</span>
                    <span class="n">writers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">writers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;_write_job&#39;</span> <span class="ow">and</span>
                                <span class="n">gen_not_started</span><span class="p">(</span><span class="n">gen</span><span class="p">)):</span>
                            <span class="c1"># has not started writing the job so can</span>
                            <span class="c1"># discard the task, but we must also remove</span>
                            <span class="c1"># it from the Pool._cache.</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">job</span> <span class="o">=</span> <span class="n">owned_by</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># removes from Pool._cache</span>
                                <span class="n">job</span><span class="o">.</span><span class="n">discard</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">job</span> <span class="o">=</span> <span class="n">owned_by</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">job_proc</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span>
                                <span class="k">if</span> <span class="n">job_proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_flush_writer</span><span class="p">(</span><span class="n">job_proc</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
                    <span class="c1"># workers may have exited in the meantime.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">()</span>
                    <span class="n">sleep</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">intervals</span><span class="p">))</span>  <span class="c1"># don&#39;t busyloop</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outbound_buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_busy_workers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_flush_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">fds</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
                    <span class="k">break</span>  <span class="c1"># process exited</span>
                <span class="n">readable</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="n">again</span> <span class="o">=</span> <span class="n">_select</span><span class="p">(</span>
                    <span class="n">writers</span><span class="o">=</span><span class="n">fds</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">fds</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">again</span> <span class="ow">and</span> <span class="p">(</span><span class="n">writable</span> <span class="ow">or</span> <span class="n">readable</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">next</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">StopIteration</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>
                        <span class="k">break</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_process_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get queues for a new process.</span>

<span class="sd">        Here we will find an unused slot, as there should always</span>
<span class="sd">        be one available when we start a new process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">items</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">owner</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_grow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grow the pool by ``n`` proceses.&quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_processes</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">create_process_queues</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_shrink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shrink the pool by ``n`` processes.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">create_process_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates new in, out (and optionally syn) queues,</span>
<span class="sd">        returned as a tuple.&quot;&quot;&quot;</span>
        <span class="c1"># NOTE: Pipes must be set O_NONBLOCK at creation time (the original</span>
        <span class="c1"># fd), otherwise it will not be possible to change the flags until</span>
        <span class="c1"># there is an actual reader/writer on the other side.</span>
        <span class="n">inq</span> <span class="o">=</span> <span class="n">_SimpleQueue</span><span class="p">(</span><span class="n">wnonblock</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">outq</span> <span class="o">=</span> <span class="n">_SimpleQueue</span><span class="p">(</span><span class="n">rnonblock</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">synq</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">assert</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">inq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">outq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">synack</span><span class="p">:</span>
            <span class="n">synq</span> <span class="o">=</span> <span class="n">_SimpleQueue</span><span class="p">(</span><span class="n">wnonblock</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">synq</span><span class="o">.</span><span class="n">_reader</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">isblocking</span><span class="p">(</span><span class="n">synq</span><span class="o">.</span><span class="n">_writer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inq</span><span class="p">,</span> <span class="n">outq</span><span class="p">,</span> <span class="n">synq</span>

    <span class="k">def</span> <span class="nf">on_process_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler called when the :const:`WORKER_UP` message is received</span>
<span class="sd">        from a child process, which marks the process as ready</span>
<span class="sd">        to receive work.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span> <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;process with pid=</span><span class="si">%s</span><span class="s1"> already exited&#39;</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span>
        <span class="k">assert</span> <span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_inq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_synq</span><span class="p">[</span><span class="n">proc</span><span class="o">.</span><span class="n">synqW_fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inqW_fd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_job_process_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">pid_gone</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler called for each job when the process it was assigned to</span>
<span class="sd">        exits.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
            <span class="c1"># job was partially written</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_partial_read</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">job</span><span class="o">.</span><span class="n">_write_to</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_scheduled_for</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">():</span>
            <span class="c1"># job was only scheduled to be written to this process,</span>
            <span class="c1"># but no data was sent so put it back on the outbound_buffer.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_job_process_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">exitcode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler called for each *started* job when the process it</span>
<span class="sd">        was assigned to exited by mysterious means (error exitcodes and</span>
<span class="sd">        signals)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mark_as_worker_lost</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">exitcode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">human_write_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;N/A&#39;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span><span class="p">))</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">per</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;{0:.2f}%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="k">if</span> <span class="n">v</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;total&#39;</span><span class="p">:</span> <span class="n">total</span><span class="p">,</span>
            <span class="s1">&#39;avg&#39;</span><span class="p">:</span> <span class="n">per</span><span class="p">(</span><span class="n">total</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_stats</span><span class="p">)</span> <span class="k">if</span> <span class="n">total</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">),</span>
            <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">per</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">),</span>
            <span class="s1">&#39;raw&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">vals</span><span class="p">)),</span>
            <span class="s1">&#39;inqueues&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;total&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_inqueues</span><span class="p">),</span>
                <span class="s1">&#39;active&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_writes</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_process_cleanup_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handler called to clean up a processes queues after process</span>
<span class="sd">        exit.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">dead</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_worker_queues</span><span class="p">(</span><span class="n">proc</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_stop_task_handler</span><span class="p">(</span><span class="n">task_handler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called at shutdown to tell processes that we are shutting down.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">proc</span> <span class="ow">in</span> <span class="n">task_handler</span><span class="o">.</span><span class="n">pool</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">setblocking</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_writer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">proc</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EBADF</span><span class="p">:</span>
                        <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">create_result_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AsynPool</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">create_result_handler</span><span class="p">(</span>
            <span class="n">fileno_to_outq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fileno_to_outq</span><span class="p">,</span>
            <span class="n">on_process_alive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">on_process_alive</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_register_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">queues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Marks new ownership for ``queues`` so that the fileno indices are</span>
<span class="sd">        updated.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">queues</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">[</span><span class="n">queues</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc</span>
        <span class="k">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_worker_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the queues owned by ``proc``.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">items</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">owner</span> <span class="o">==</span> <span class="n">proc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this is only used by the original pool which uses a shared</span>
        <span class="c1"># queue for all processes.</span>

        <span class="c1"># these attributes makes no sense for us, but we will still</span>
        <span class="c1"># have to initialize them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inqueue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outqueue</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_quick_put</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quick_get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll_result</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">process_flush_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flushes all queues, including the outbound buffer, so that</span>
<span class="sd">        all tasks that have not been started will be discarded.</span>

<span class="sd">        In Celery this is called whenever the transport connection is lost</span>
<span class="sd">        (consumer restart).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resq</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">outq</span><span class="o">.</span><span class="n">_reader</span>
        <span class="n">on_state_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_handler</span><span class="o">.</span><span class="n">on_state_change</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">resq</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">fds</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">resq</span><span class="o">.</span><span class="n">closed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">TERMINATE</span><span class="p">:</span>
            <span class="n">readable</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">again</span> <span class="o">=</span> <span class="n">_select</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">fds</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">readable</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">task</span> <span class="o">=</span> <span class="n">resq</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EINTR</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;got </span><span class="si">%r</span><span class="s1"> while flushing process </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="n">exc</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">get_errno</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">UNAVAIL</span><span class="p">:</span>
                        <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;got </span><span class="si">%r</span><span class="s1"> while flushing process </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="n">exc</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;got sentinel while flushing process </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">on_state_change</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">on_partial_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when a job was only partially written to a child process</span>
<span class="sd">        and it exited.&quot;&quot;&quot;</span>
        <span class="c1"># worker terminated by signal:</span>
        <span class="c1"># we cannot reuse the sockets again, because we don&#39;t know if</span>
        <span class="c1"># the process wrote/read anything frmo them, and if so we cannot</span>
        <span class="c1"># restore the message boundaries.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">_accepted</span><span class="p">:</span>
            <span class="c1"># job was not acked, so find another worker to send it to.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_put_back</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">_get_job_writer</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">writer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_writers</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
            <span class="k">del</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">dead</span><span class="p">:</span>
            <span class="n">proc</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># Replace queues to avoid reuse</span>
            <span class="n">before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_worker_queues</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">destroy_queues</span><span class="p">(</span><span class="n">queues</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">create_process_queues</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="p">)</span> <span class="o">==</span> <span class="n">before</span>

    <span class="k">def</span> <span class="nf">destroy_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queues</span><span class="p">,</span> <span class="n">proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Destroy queues that can no longer be used, so that they</span>
<span class="sd">        be replaced by new sockets.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">_is_alive</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_start</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proc</span><span class="p">)</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queues</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">queues</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_inqueue_close</span><span class="p">(</span><span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">proc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">queue</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sock</span> <span class="ow">in</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">_reader</span><span class="p">,</span> <span class="n">queue</span><span class="o">.</span><span class="n">_writer</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">sock</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
                            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">removed</span>

    <span class="k">def</span> <span class="nf">_create_payload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                        <span class="n">dumps</span><span class="o">=</span><span class="n">_pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">,</span> <span class="n">pack</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">((</span><span class="n">type_</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&gt;I&#39;</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">size</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_set_result_sentinel</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">_outqueue</span><span class="p">,</span> <span class="n">_pool</span><span class="p">):</span>
        <span class="c1"># unused</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_help_stuff_finish_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Pool._help_stuff_finished is a classmethod so we have to use this</span>
        <span class="c1"># trick to modify the arguments passed to it.</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="p">,</span> <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_help_stuff_finish</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
        <span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;removing tasks from inqueue until task handler finished&#39;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fileno_to_proc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">inqR</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fd</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_reader</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
                <span class="n">inqR</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
                <span class="n">fileno_to_proc</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">while</span> <span class="n">inqR</span><span class="p">:</span>
            <span class="n">readable</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">again</span> <span class="o">=</span> <span class="n">_select</span><span class="p">(</span><span class="n">inqR</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">again</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">readable</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">readable</span><span class="p">:</span>
                <span class="n">fileno_to_proc</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="o">.</span><span class="n">inq</span><span class="o">.</span><span class="n">_reader</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maintain_pool</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">}</span>
</pre></div>

          </div>
        </div>
      </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Celery 3.1.23 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../concurrency.html" >celery.concurrency</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; <a href="../../../copyright.html">Copyright</a> 2009-2015, Ask Solem &amp; Contributors.
    </div>
  </body>
</html>
